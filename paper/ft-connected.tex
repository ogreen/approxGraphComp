\input{ftsv-algm}

As a motivation for proposed algorithm, we analyze effects of silent data corruption in the~\sv~algorithm on convergence of the algorithm.

\subsection{Fault Propagation}
In presence of faults, the $CC$ vector may get corrupted.
Corruption of $CC$ vector may result in slower convergence, converging to incorrect results, or converging to a result which may be considered technically-correct, however it may not be correct from
convention of output. For instance, in presence of fault 
 final connected component id is second minimum, as oppose to minimum according to our convention.
We consider such cases as incorrect results, as consumer application of the algorithm may use properties of defined convention.


To analyze propagation of data corruption in $CC$ vector, consider any vertex $v$, and it's $CC$ value in the $i$-th 
iteration as $CC^{i}[v]$. Let $CC^{\infty}[v]$ be the final $CC$ value of $v$ in case of fault free execution. Suppose a fault occurs and due to the fault $CC^{i}[v]$ is changed to $\hat{CC}^{i}[v]$.
Now depending on value of $\hat{CC}^{i}[v]$, the data corruption may propagate, or will be corrected in a later iteration. We consider following two cases:

\paragraph{Case 1: $\hat{CC}^{i}[v] > CC^{\infty}[v]$} 
In this case, since minimum $CC$ in the connected component remains unchanged,  $\hat{CC}^{i}[v]$ will be eventually overwritten by $CC^{\infty}[v]$. However, it may still delay convergence and if $v$ is minimum vertex id in the connected component, i.e. $CC[v]=CC^{\infty}[v]$, connected component will converge to second minimum vertex-id, thus giving incorrect result.


\paragraph{Case 2: $\hat{CC}^{i}[v] < CC^{\infty}[v]$} 
In this case, minimum $CC$ in the connected component is changed and, thus $\hat{CC}^{i}[v]$ will propagate to all other vertex, resulting in converging to incorrect results.

THe difficulty is, looking at $CC$ array it is not possible to determine if: a) a fault has occurred that needs corrections; b) algorithm will converge to correct answer. To felicitate, determining if the algorithm is in valid state, we introduce another vector that we call \emph{parent} vector denoted by $H$. 
For each vertex, the $H$ vector stores the vertex that caused the last change in its $CC$ value.
For instance, if in a given iteration, $CC[v]>CCp[u]$, then~\sv algorithm updates $CC[v]\leftarrow CCp[u]$, 
and we correspondingly we update $H[v]\leftarrow u$.
We present following theorem that establishes validity of a state vector. 

\begin{thm}
\label{thm:strong-SV-converg-cond}
Given a graph $G=(V,E)$ and a arbitrary state vector $S=(CC,H)$, the~\refalg{alg:SV_ALG} starting from $S$ will converge to correct solution defined by [insert ref to definition], if $S$ satisfies following condition:
%
\begin{enumerate*}
\item Parent of any vertex $v$ is either $v$ itself or it is one of neighbor: $H(v) \in \{ v, E(v)\}$;

\item if $H(v)=v$, then $CC(v)=v$;

\item $CC[v]\leq v$;

\item $CC[v]\geq CC[H[v]] $ ;and

\item There are no loop except self-loops in the directed graph $G^{*}$ defined by $G^{*} = (V,E^{*})$,
 where $E^{*}=\{ (v,H(v)) \forall v \in V \}$ .
\end{enumerate*}
\end{thm}

\subsection{Fault tolerant~\sv Algorithm}
In principle~\refthm{thm:strong-SV-converg-cond} can be used to construct a fault detection and correction scheme. 
Im theory,  such a fault detection and correction scheme may not require detection and correction 
step to be executed in every iteration, and its frequency can be a tuning parameter. 
However, there are a few challenges in realizing such a detection and correction step. 
First, while condition 1,2, and 3 can be verified using $\mathcal{O}(1)$ computation for each vertex , verifying
condition 4 would require $\mathcal{O}(d)$ computation for each vertex~\cite{brent1980cycle}. 
Moreover, correcting the state variables would be even more costly. 

This problem can be overcome if we assume that $S^{i}=(CC^{i},H^{i})$ vector from previous iteration was correct.
If $S^{i}$ satisfies conditions from~\refthm{thm:strong-SV-converg-cond}, and a faulty~\sv iteration
is executed to compute $s^{i+1} = (CC^{i+1},H^{i+1})$:
\[
(CC^{i+1},H^{i+1}) \leftarrow fSV (G,CC^{i}) 
\] 
then, there will not be any loop as long as $S^{i+1}$ satisfies condition 1, 2 and 3 of ~\refthm{thm:strong-SV-converg-cond}. Thus, fault detection and correction becomes computationally more tractable.

To detect a fault, after each faulty~\sv iteration, we check condition 1, 2 and 3 of ~\refthm{thm:strong-SV-converg-cond}. Checking for condition 2, 3, and 4 require $mathcal{O}(1)$ computations. 

 To check for any vertex $v$ whether $H(v) \in \{ v, E(v)\}$, in a naive algorithm, 
we may traverse through adjacency list of vertex $v$, and check if $H(v)$ is indeed a neighbor of $v$. However, doing so for each vertex will require $\mathcal{O}(|V|+|E|)$ computations. It may be speeded-up by using binary search, which may reduce complexity to $\mathcal{O}(|V|log(|V|))$, which may be still high. 
We  overcome this problem by storing relative address of $H(v)$ in the adjacency list instead of storing absolute vertex-id of $H(v)$.
 In other words, if $H(v)$ is $ind$-th entry in the adjacency list of $v$, .i.e $H[v]=E[v][ind]$, 
 then we store $ind$. This reduces the checking if $H(v)\in{v,E(v)}$ to checking if $ind<|E(v)|$.  Thus, checking first condition becomes $\mathcal{O}(1)$ operations. 
 Therefore total overhead of fault detection is  $\mathcal{O}(|V|)$.

If a fault is detected for any vertex $v$, we correct it by calculating $CC[v]$ again. 
If we assume fault rate is $f$, and average degree of any vertex is $\mathcal{O}(|E|/|V|)$, 
then cost of correction will be $\mathcal{O}(f|E|/|V|)$.

Since, weak condition require that $CC$ from previous iteration should be correct, for algorithm
to converge to correct value, in this work, we assume that fault detection and corrections steps 
are done in a reliable mode.  \refAlgorithm{alg:FTSV_ALG} shows the complete algorithm.
We list overhead of~\refalg{alg:FTSV_ALG} in 

\begin{table}[htbp]
\centering
\caption{Overhead of \ftsv}
\label{tab:overhead}
\begin{tabular}{l|l}
\toprule 
                 & Asymptotic Overhead     \\
\midrule                  
Memory           & $\mathcal{O}(|V|)$      \\
Fault Detection  & $\mathcal{O}(|V|)$      \\
Fault Correction & $\mathcal{O}(f|E|/|V|)$ \\
\bottomrule 
\end{tabular}
\end{table}