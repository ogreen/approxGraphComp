#LyX 2.2 created this file. For more info see http://www.lyx.org/
\lyxformat 508
\begin_document
\begin_header
\save_transient_properties true
\origin unavailable
\textclass IEEEtran
\options conference
\use_default_options false
\maintain_unincluded_children false
\language english
\language_package default
\inputencoding iso8859-15
\fontencoding T1
\font_roman "default" "default"
\font_sans "default" "default"
\font_typewriter "default" "default"
\font_math "auto" "auto"
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100 100
\font_tt_scale 100 100
\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\paperfontsize default
\spacing single
\use_hyperref false
\papersize default
\use_geometry false
\use_package amsmath 2
\use_package amssymb 0
\use_package cancel 0
\use_package esint 1
\use_package mathdots 0
\use_package mathtools 0
\use_package mhchem 0
\use_package stackrel 0
\use_package stmaryrd 0
\use_package undertilde 0
\cite_engine basic
\cite_engine_type default
\biblio_style plain
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\justification true
\use_refstyle 0
\index Index
\shortcut idx
\color #008000
\end_index
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\paragraph_indentation default
\quotes_language english
\papercolumns 2
\papersides 1
\paperpagestyle default
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Paragraph
Label Propagation algorithm in Fault Free execution
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide true
sideways false
status collapsed

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout
\begin_inset Graphics
	filename figure/sv1.pdf
	width 20page%

\end_inset


\begin_inset Graphics
	filename figure/sv2.pdf
	width 20page%

\end_inset


\begin_inset Graphics
	filename figure/sv3.pdf
	width 20page%

\end_inset


\begin_inset Graphics
	filename figure/sv4.pdf
	width 20page%

\end_inset


\begin_inset Graphics
	filename figure/sv5.pdf
	width 20page%

\end_inset


\begin_inset Caption Standard

\begin_layout Plain Layout
These sub-figures conceptually show how the connected component id propagates
 through the graph as time evolves.
 Subfigures represent snapshots of the algorithm at different times.
 For simplicity, this example assumes that all the shown vertices are connected.
 Initially the number of connected components is equal to the number vertices.
 (a) Depicts the initial state in which each vertex is in its own component.
 (b)-(d) depict that some vertices belong to the same connected component
 yet may require multiple label updates (in either the same iteration or
 a separate iteration).
 (e) is the final state in which there is a single connected component.
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float table
wide false
sideways false
status open

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
input{symbolTab}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
The aim of label propagation algorithm is to mark every vertex in a given
 connected component with a pre-defined common label.
 This common label is same within each connected component, and different
 across different connected component.
 There are many choice for the common label.
 As a convention, we consider minimum vertex-id in the connected component
 as the final common label.
 
\end_layout

\begin_layout Standard
The label propgation algorithm keeps an array 
\begin_inset Formula $CC$
\end_inset

 of current labels for all vertices.
 For each vertex 
\begin_inset Formula $v$
\end_inset

, its label 
\begin_inset Formula $CC[v]$
\end_inset

 is initalized with its vertex-id 
\begin_inset Formula $CC[v]=v$
\end_inset

.
 In every iteration, each vertex updates its label by calculating minimum
 label of all its neighbours and itself:
\begin_inset Formula 
\begin{equation}
CC^{i+1}[v]=\min_{u\in\mathcal{N}(v)}CC^{i}[u],\label{eq:lp_update_eqn}
\end{equation}

\end_inset


\end_layout

\begin_layout Standard
where 
\begin_inset Formula $\mathcal{N}(v)=\left\{ v,adj(v)\right\} $
\end_inset

 is the defined as immidiate neighbourhood of 
\begin_inset Formula $v$
\end_inset

.
 Thus, through out the iteration minimum vertex id propagates to all the
 vertces in the connect component.
 The iteration converges when there are no more label changes in the graph.
 
\end_layout

\begin_layout Standard
Depending on the constrints, equation 
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:lp_update_eqn"

\end_inset

 can be implmented in two ways.
 In the first way, we use two different arrays to store 
\begin_inset Formula $CC^{i+1}$
\end_inset

 and 
\begin_inset Formula $CC^{i}$
\end_inset

.
 We refer to this implementation is Sync LP algorithm.
 In an another way, we overwrite 
\begin_inset Formula $CC^{i+1}$
\end_inset

 on 
\begin_inset Formula $CC^{i}$
\end_inset

.
 We refer to this version as Async LP algorithm.
 Depending on architecture and programming model, the two variants may have
 different performance characteristics.
 In subsequent discussion, we assume Async LP algorithm.
 Yet, our results are equally applicable to both instance of the LP algorithm.
\end_layout

\begin_layout Standard
Each iteration of LP, visits all the vertex and edges once and thus costs
 
\begin_inset Formula $\mathcal{O}(V+E)$
\end_inset

.
 The LP algorithm requires 
\begin_inset Formula $\mathcal{O}(d)$
\end_inset

 iterations to converge, where 
\begin_inset Formula $d$
\end_inset

 is the diameter of the graph.
 We may use short-cutting to bound the number of iteration to 
\begin_inset Formula $\mathcal{O}(log(d))$
\end_inset

 [insert citation].
 However, in practice async LP algorithm only takes a few more iteration
 than implementing full short cutting step, without the cost of short cutting.
 
\end_layout

\end_body
\end_document
