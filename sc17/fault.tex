
We term fault as any instance of hardware deviating from its expected
behavior. Impact of such faults on the application can vary  depending on the
location of the fault. Based on the impact of the faults, they can be
classified into two broad categories: hard fault and soft faults. A hard fault
causes the application to terminate prematurely. For instance, failing of nodes and network fall
into this category. On the other hand, soft faults may not cause the
application to abort. Even so, a soft fault can lead to an incorrect result,
which we term as the failure. Bitflips in memory and latches are examples of
soft faults. Interested readers can find a more detailed discussion on faults
elsewhere  \cite{hoemmen2011ftgmres}.

In this paper, we only deal with soft faults. A particularly insidious
manifestation of soft-faults is silent data corruption. Silent data corruption
occurs when a soft fault leads to corruption of entire intermediate variables,
without notifying the application. In such cases, the application may arrive
at an incorrect solution and yet, report it as correct solution. Thus, silent
data corruption can lead to serious reliability issues in the computing. 


The importance of having algorithmic level fault tolerance has already been
explored for a number of numerical computations (see \cref{sec:related}). Graph
computations are equally susceptible to soft faults as numerical computation.
Researchers have started looking at resilient discrete computation only
recently (\TODO{cite})

