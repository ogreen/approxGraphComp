
In this section, we discuss how abstraction of an algorithm as a state machine
may help us to make them more resilient.

An iterative algorithm can also be viewed as a system with states and
transition rules. Its \emph{state} is a subset of the intermediate variable
which enables continued execution. For instance, the vector $CC$ in
\cref{alg:SV_ALG} alone is sufficient to restart the algorithm from any
checkpoint. In general, the state of the algorithm can have or can be
augmented to have some form of  redundancy built in it.   %In
\cref{alg:SV_ALG}, the variable $P$  acts as an useful redundancy.
\paragraph{Valid and invalid states} A state of the algorithm is said to be in
a valid state if the algorithm will converge to a correct solution in fault-
free execution starting from this state, otherwise invalid. In previous work
\TODO{cite}, we have shown that such abstraction may help us to construct
resilient algorithms.



\paragraph{Impact of hardware fault on algorithms state}

If an algorithm is well suited for a given problem then in a fault-free
execution, its state remains valid during entire computation. However,
soft-fault such as bit flip can corrupt the intermediate variables
and, can potentially bring it to an invalid state. Subsequent fault-free
execution will lead to an incorrect solution, thus failure, unless
it is brought to a valid state by some mechanism. Our principle for
designing fault-tolerant algorithm is based on the idea of augmenting
the algorithm so that it can bring itself to a valid state, by design.
We distinguish between following two principles for bringing the algorithm
to a valid state.

\paragraph{Self-stabilizing algorithm} Formally, a system is said to be self-
stabilizing, if starting from any arbitrary \emph{state}, it comes to a valid
state in a finite number of steps\cite{dijkstra1982self}. If a fault causes an
algorithm to reach an invalid state, a self-stabilizing algorithm will come to
a valid state in a finite number of iterations. Subsequently, the algorithm
will converge to the correct solution if all the later computations do not
encounter any fault.

\paragraph{Self-correcting algorithm}

A self-correcting algorithm can bring itself to a valid state by correcting
its state with information of a previous valid state. In contrast
to self-stabilization algorithm, a self-correcting must start from
a valid state. In reality, it is not such a limitation as most algorithms
by design starts from a valid state. On the other hand, the self-correcting
algorithm can be more efficient than the self-stabilizing algorithm,
as it can meaningfully exploit information of a previous valid state.
In {[}cite{]}, we presented a self-correcting of SYNC version of label
propagation algorithm. 


