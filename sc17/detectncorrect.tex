%

In this section, we describe how do we use the  \cref{thm:ss_valid} to verify
whether a state is valid. Specifically, the challenge is in verifying the
condition-5 of \cref{thm:ss_valid} in parallel. Further, we also need a
mechanism to bring the algorithm to a valid state if we detect an invalid
state.


Except for the condition-5 of the \cref{thm:ss_valid}, we can verify all other
conditions \emph{locally} and in parallel.  Here, the term local means by only
using information that a vertex has access to. Condition 1-4 can be verified
for any vertex by looking at it's  and it's neighbor's label and parent.
Whereas we can not detect a loop just by looking at a vertex and it's
neighbors.

The traditional algorithms for finding a loop in a directed graph are not well
suited for vertex-centric programming. The problem of finding the loop in a
directed graph is also known as the problem of finding strongly connected
components in a graph. In sequential case, one can use Tarzen's strongly
connected component algorithm, or breadth search first(BFS), or depth search
first (DFS) \TODO{CITE}.  These algorithm run at $\bigo{|V| + |E|}$ cost.  In the
graph $H$, the number of edges and vertices are equal: $|V|=|E|$. So the cost
of these algorithms will be $\bigo{|V| }$. As other checks of
\cref{thm:ss_valid} costs $\bigo{|V| }$ so $\bigo{|V| }$ cost of loop
detection is, in theory, acceptable.  Yet due to limited parallelism and
inability to express in the vertex-centric model, we can not use these to
verify the condition-5 of the \cref{thm:ss_valid}.


\subsection{Parallel Loop Detection}

We present a new algorithm for detecting loops in the directed graph where
each vertex has degree one such as $H$. The key idea of our algorithm is that,
if there are no loops in the graph $H$, then a non-root vertex $v$ cannot be
an ancestor of itself.


Consider the following sequence $\mathcal{P}(v)$ of ancestors of a non-root vertex $v$ 
\begin{equation}
\mathcal{P}(v)=\left\{ P(v),\ P^{2}(v),\ldots\right\}. 
\end{equation}
%
If  there are no loops in $H$, then $\mathcal{P}(v)$ will converge to root of
the tree which $v$ belongs. But if $v$ is a part of the loop, then
$\mathcal{P}(v)$ will become periodic  and cycle through all the vertex in the
loop indefinitely.  So the calculation of  $\mathcal{P}(v)$ may not be used
for detecting loops in $H$.  I

Instead of $\mathcal{P}(v)$,  we consider the minimum vertex-id among all the
vertex that are ancestors of vertex $v$. We denote it as  $\mathcal{A}(v)$: 
\begin{equation}
\mathcal{A}(v) = \min\mathcal{P}(v)=\min\left\{ P(v),\ P^{2}(v),\ldots\right\}. 
\end{equation}
%
In the fault-free case, both $\mathcal{A}(v)$ and $\mathcal{P}(v)$ will
converge to the root of the tree. But unlike $\mathcal{P}(v)$, the calculation
of $\mathcal{A}(v)$ will converge even if there is a loop in $H$.

\subsubsection{Loop Detection using $\mathcal{A}(v)$}

If there are no loops in $H$, then a non-root vertex $v$ cannot be equal to
$\mathcal{A}(v)$. That's because  if there are no loops then $v\notin
\mathcal{P}(v)$.  Verily,  if we find a non-root vertex such that
$v=\mathcal{A}(v)$ then following two condition holds:
%
\begin{enumerate}
\item $v$ is a vertex in a loop in $H$; and 
\item $v$ has the smallest vertex-id in the loop.
\end{enumerate}


