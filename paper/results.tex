%%% result.tex 
%% displays experimental setup, and description of matrices 
We performed a series of experiments to test robustness and overhead of our algorithm described in~\refsec{sec:connected}. 

%
\subsection{Fault Injection Methodology}
Since memory accesses are most performance critical part in~\sv computation, we inject faults in memory access pattern. There are two main memory accesses in~\sv iteration: traversing adjacency list for each vertex; and 
accessing $CC$ array for each vertex in adjacency list. 

In the first case, before each~\sv sweep, we randomly select $f|E|$ edges, where $f$ is fault-rate. Let $e=(v,u)$ be  one of the selected edges. When we encounter $e$ while traversing adjacency list of $v$, we flip one of the bits of $u$---the vertex which $e$ is pointing---randomly. 
Therefore, due to the fault, $v$ will visit flipped vertex $\hat{u}$, instead of accessing $u$. 

In the second case, we will again choose another set of $f|E|$ edges. Let $e=(v,u)$ be  one of the selected edges. When we encounter $e$ while traversing adjacency list of $v$, we flip one of the bits of $CC[u]$.
Therefore, due to the fault, $v$ will visit the correct vertex, however, it see incorrect value of  $CC[u]$.
It should be noted that $CC[u]$ will be accessed multiple times in a~\sv iteration, and we assume that 
all accesses to $CC[u]$ in an iteration are independent. In other words, if $CC[u]$ is accesses while visiting 
vertex $v_{1},\ v_{2}$, and if $CC[u]$ is corrupted while visiting $v_{1}$, then $CC[u]$ may or may not be corrupted when it is accessed while visiting $v_{2}$.


\subsection{Experimental Setup}



% type of matrices 
\paragraph{Test Graphs}
The graphs used in our tests are listed in~\reftab{tab:graphs}. 
These graphs are taken from the 10th Dimacs Implementation Challenge~\cite{Bader-dimacs-graph2014}, come from various real and synthetic applications. 
\input{matrix_table}

\paragraph{Testbed}
\input{sysinfo_table}
We prototyped baseline and fault tolerant implementation using $C$ language. 
We used the Intel C Compiler (ICC 15.0.0), with highest level of
 optimization $-O3$ to compile our benchmarks.
We ran all our experiments on SNB16c, key properties of the systems are listed in~\reftab{tab:sys_info}


\subsection{Convergence in presence of faults}


\subsection{Overhead of fault detection and correction}
%% compare it with double modular redundancy 

