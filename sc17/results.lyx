#LyX 2.2 created this file. For more info see http://www.lyx.org/
\lyxformat 508
\begin_document
\begin_header
\save_transient_properties true
\origin unavailable
\textclass IEEEtran
\options conference
\use_default_options false
\maintain_unincluded_children false
\language english
\language_package default
\inputencoding iso8859-15
\fontencoding T1
\font_roman "default" "default"
\font_sans "default" "default"
\font_typewriter "default" "default"
\font_math "auto" "auto"
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100 100
\font_tt_scale 100 100
\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\paperfontsize default
\spacing single
\use_hyperref false
\papersize default
\use_geometry false
\use_package amsmath 2
\use_package amssymb 0
\use_package cancel 0
\use_package esint 1
\use_package mathdots 0
\use_package mathtools 0
\use_package mhchem 0
\use_package stackrel 0
\use_package stmaryrd 0
\use_package undertilde 0
\cite_engine basic
\cite_engine_type default
\biblio_style plain
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\justification true
\use_refstyle 0
\index Index
\shortcut idx
\color #008000
\end_index
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\paragraph_indentation default
\quotes_language english
\papercolumns 2
\papersides 1
\paperpagestyle default
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Standard
We performed a series of experiments to test the robustness of the self-stabiliz
ing algorithms in the sec[x].
 We focus on evaluating overhead and convergence property in presence of
 soft faults.
 
\end_layout

\begin_layout Standard
While there is not much different in applying self-stabilization to Async
 and Sync vriants, we focus only on Async case here.
 Async case is considerably more difficult than Sync case, as in Async case
 a single fault can propagate to multiple vertices in a single iteration.
 Moreover, Async case keeps only a single copy of the state, so self-correction
 approach taht works well on Sync case, will not work on Async case
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
We compared the self-correcting and the self-stabilizing algorithm for Sync
 algorithm, and self-correcting label propagation performs definitively
 better.
\end_layout

\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Note Comment
status collapsed

\begin_layout Plain Layout

\series bold
\emph on
p
\series default
urpose of this section
\emph default
 
\end_layout

\begin_layout Itemize
what do we want to show 
\end_layout

\begin_layout Itemize
why do we want to show 
\end_layout

\begin_layout Itemize
how do we want to show 
\end_layout

\begin_layout Paragraph

\series bold
\emph on
e
\series default
xperimental setup
\emph default
 
\end_layout

\begin_layout Itemize
system description 
\end_layout

\begin_layout Itemize
programming environment 
\end_layout

\begin_layout Itemize
test matrices 
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Experimental set-up
\end_layout

\begin_layout Subsubsection
Test-bed
\end_layout

\begin_layout Standard
We prototyped our implementation in C and compiled with Intel C compiler
 (insert compiler version) with 
\begin_inset Formula $O3$
\end_inset

 optimization flages.
 We ran our experiments in a dual socket Ivy-bridge with 
\begin_inset Formula $2\times8$
\end_inset

cores running at 2.66GHz.
 This testbed had 128GB DRAM and 12Mb of L3.
\end_layout

\begin_layout Subsubsection
Test-networks
\end_layout

\begin_layout Standard
We choose networks from real applications with diverse sparsity pattern,
 density, degree distribution and component distribution.
 In table[x], we list the networks along with some properties.
\end_layout

\begin_layout Standard
\begin_inset Float table
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
List of the matrices
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
input{networktable}
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Fault injection methodology
\end_layout

\begin_layout Standard
We inject bitflips in memory operation to simulate faults.Specifically, we
 inject bitflips in two main memory operation: a) reading adjacency tree,
 and b) reading labels of neighbours.
 Bitflip in an array-index value may cause memory segmentation error and
 abort.
 Therefore, we gaurd susceptible array-index variable with a range check.
 If the variable is out of range, we change it to random value within range.
\end_layout

\begin_layout Subsubsection
Competing algorithms
\end_layout

\begin_layout Standard
In our experiments, we compare the following representative fault tolerant
 algorithms:
\end_layout

\begin_layout Enumerate
Baseline: Algm(x) 
\end_layout

\begin_layout Enumerate
TMR: Triple modular redundancy 
\end_layout

\begin_layout Enumerate
SsLP: Self-stabilizing LP iteration without any checks.
 
\end_layout

\begin_layout Enumerate
HSsLP: Self-stabilizing LP iteration with unreliable checks.
 
\end_layout

\begin_layout Standard
\begin_inset Separator plain
\end_inset


\end_layout

\begin_layout Subsection
Failure Test
\end_layout

\begin_layout Standard
The aim of failure test is to quantify the frequency of the event when an
 algorithm fails to give the correct results, indepedent of any incurred
 overhead.
 This is done by executing each algorithm multiple times for a given network
 in simulated random fault environment with different seeds for random number
 generation.
 We compare the four algorithms based on the success rate at a specific
 fault rate.
 The fault rate is chosen from 
\begin_inset Formula $\{2^{-5},2^{-6},\ldots2^{-20}\}$
\end_inset

 bitflips per memory operation at which TMR fails for roughly 50% of the
 trials.
 
\end_layout

\begin_layout Standard
Note that SS SSH LP algorithm will almost always give correct results if
 we do not limit number of iterations to converge.
 However, this doesn't reflect the practical use of the algorithm.
 Thus, in our experiments we limit the number of iteration to 100.
 If an algorithm doesn't converge by 100 iteration, it aborts and reports
 failure.
 
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Graphics
	filename plots/failureTest_async_first_0.50.pdf
	width 90col%

\end_inset


\begin_inset Caption Standard

\begin_layout Plain Layout
Success rate for different different test networks 
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
In fig(x), we show the success rate of different algorithm for different
 graphs at TMR50.
 Note that this fault inject rate so high that traditional redundancy based
 fault tolerance algorithm will fail in ~50% of the cases.
 In fig(x), we see that SShSv has a success rate of more than 90% in 9 out
 of eleone cases.
 SShSv is better than TMR in 8 out of 11 cases.
 
\end_layout

\begin_layout Standard
There are two graphs kron_g and mouse_gene where all the algorithm have
 very good success rate.
 This is typically the case when the graph is relatively dense.
 RGG is one random graph where Baseline and TMR have 100% success rate but
 both SsSv and SShSV performs extremely poorly.
 This usually happens when a graph has a lot of tree like structure.
 In such cases even though sssv and sshsv have converged to correct solution,
 they may still find a 2-loop 
\end_layout

\begin_layout Subsection
Convergence Test
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide true
sideways false
status open

\begin_layout Plain Layout
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Graphics
	filename plots/astro-ph_async_12_hist.pdf
	width 40page%

\end_inset


\begin_inset Caption Standard

\begin_layout Plain Layout
Histogram of iteration distribution
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\begin_inset space \hfill{}
\end_inset


\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Graphics
	filename plots/astro-ph_async_12_line.pdf
	width 40page%

\end_inset


\begin_inset Caption Standard

\begin_layout Plain Layout
Cumulative success rate with respect to addition iteration to converge
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Success rate for different different test networks 
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Overhead of Correction step
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Graphics
	filename plots/timetest.pdf
	width 95col%

\end_inset


\begin_inset Caption Standard

\begin_layout Plain Layout
Overhead of correction step for different networks
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\end_body
\end_document
