The first contribution of this paper is \cref{thm:ss_valid} that defines a set
of conditions that are sufficient to verify the validity of a state. We use
\cref{thm:ss_valid} to construct a correction step described in \cref{sec:ft-
connected} that can be used to bring the algorithm in a valid state.




\subsection{Impact of faults in \sv~algorithm}

\begin{thm}{ \textbf{Valid States:}}
\label{thm:valid_cc}
A connected component array $CC$ is a valid state---i.e., a fault-free
execution of algorithm starting from $CC$ will converge to
the correct solution---if, for all vertices $v$, $CC^{\infty}[v]\leq CC[v]\leq v$ (\cite{sao2016sccc}).
\end{thm}



\subsection{Self-correcting \sv~algorithm}

The problem with \cref{thm:valid_cc} is that it defines the validity of the
based on the final and correct output. Thus, it can not be used to check the
validity of the state.  In our previous work \cite{sao2016sccc}, we presented
the following set of conditions that can be used to check the validity.

\begin{thm}
\label{thm:sc-sv}
Given a valid state for the previous iteration, $CC^{i-1}$, the current connected component array $CC^{i}$ is a valid state if for all vertices $v$, $CC^{i}$ satisfies these conditions:
\begin{enumerate}
\item $CC^{i}[v] \leq v$; 
\item $CC^{i}[v] = CC^{i-1}[P(v)]$; and
\item $P(v) \in \mathcal{N}(v)$. %$u \in \left\{ v \right\} \cup adj(v)$.
\end{enumerate}
\end{thm}


The conditions of  the \cref{thm:sc-sv} can be verified in $\bigo{1}$ time for
any vertex $v$ \cite{sao2016sccc}. Thus,   we can check validity for all
vertices in  $\bigo{V}$ time. We can cheaply recompute the labels for the
vertices  which do not satisfy \cref{thm:sc-sv} using the valid previous state
$CC^{i-1}[v]$.

% The \cref{thm:sc-sv}  assumes and can only work correctly when the previous state $CC^{i-1}$  is valid.  

The \cref{thm:sc-sv}  assumes and can only work correctly when the previous state $CC^{i-1}$  is valid. In the \emph{self-correcting} label propagation algorithm,  we verify conditions of \cref{thm:sc-sv} after every iteration to ensure that the algorithm is in a valid state; and \cref{thm:sc-sv} can be used to detect and correct next invalid states. 

\subsubsection{Limitations of Self-correcting \sv~algorithm}
The \emph{self-correcting} algorithm can only work when we have the copy of previous valid labels  $CC^{i-1}$. Thus, the \emph{self-correcting} \sv algorithm will not work with \async~formutation of the \sv algorithm. 

In some cases, such as dynamic graphs, we would like to start the algorithm from a previously calculated state. For such states, we do not know whether they are valid for the changed graph.  The \emph{self-correcting} algorithm cannot work in such cases either.


\subsection{ Self-stabilizing Validity Conditions}

Given an arbitrary state $S=\{CC, p\}$, can we determine whether it is valid
or not?  To answer this, we present an extended version of \cref{thm:sc-sv}
which does not assume anything about prior iterations.

The key idea here is, that information about past iterations are already
present in $S=\{CC, p\}$.  Specifically, the $P$ contains the information
about how a label has propagated to vertex $v$. To put it concretely,  we
present following properties of $P$.

\subsubsection{ Relation between $CC[v]$ and $CC[P(v)]$} 

 In the fault-free execution of  \sv algorithm,  label of a vertex $CC[v]$ is
always greater than orequal to its parent's label  $CC[P(v)]$. Any vertex $v$
acquires its label from its $P(v)$ in some iteration $j\leq i$. So the current
label of vertex $v$ is $CC^{i}[v]=CC^{j}[P(v)]$. In the \sv algorithm, labels
of any vertex can only decrease as the iteration progresses. Thus, the current
$P(v)$'s current label $  CC^{i}[P(v)] $ must be smaller than or equal to its
ealier value $CC^{j}[P(v)]$.  Therefore,  $CC^{i}[v] =CC^{j}[P(v)] \geq
CC[P(v)]$.

\begin{equation}
\label{eq:ccv-ccp}
CC[v] \geq CC[P(v)].
 \end{equation}

Additionally, if any vertex is the parent of itself, i.e. $P(v)=v$ then
$CC[v]=v$.  In \cref{alg:SV_ALG}, all the vertices have initialized with
$P(v)=v$ and $CC[v]=v$. If a vertex never changes it's label during
\sv~iterations, then it will retain its parent and label. Conversely, if a
vertex has changed its value then $CC[v]<v$ and $P(v)\neq v$. Moreover, a
changed $P(v)\neq v$ will never revert back to $P(v)=v$ as $P(v)$  only
changes when $CC[v]$ is changed. So $P(v)=v$ implies $v$ obtained a label from
itself, which is not possible. Therefore, in fault free execution of
\cref{alg:SV_ALG} we must have following for all vertices $v$:

\begin{equation}
\label{eq:root-cc}
CC[v] = v \ iff P(v)=v.
\end{equation}
 


\begin{defn}{ \textbf {Propagation Graph $H$:} }
\label{def:prforH}
For a given state $S=\{ CC, P\}$ for execution of \cref{alg:SV_ALG} with input 
$G=\{V,\ E\}$,  \emph{Propagation Graph} $H$ is the directed graph defined by $H=\{V,\ E_{H}\}$ where the edge set $E_{H}$ consists of directed edges $v\rightarrow P(v)$ for all $v \in V$. 
\end{defn}

\subsubsection{ Structure of the Parent Graph $H$} In the fault-free execution of
\cref{alg:SV_ALG}, the propagation graph $H$ does not contain any loops
besides self-loop. Thus, $H$ consists of multiple trees.  The label of roots
of each tree is a \emph{local- minima} of labels. When the iteration is
converged, $H$ is one tree of each component in the graph. A path from any
vertex to the root of its tree is also the path by which root's label propagated 
to that vertex, albeit in reverse.

Now we can formally state and prove the following set of conditions on any arbitrary state $S$, which is sufficient to assert its validity.

\begin{thm}
\label{thm:ss_valid}
Starting from state $S= \{CC,P \}$, the \cref{alg:SV_ALG} will converge to correct solution for graph $G=\{ V, E\}$, if $S$ satisfies the following conditions.
\begin{conditionList}
\item \label{cond:ccv_leq_v} $CC[v]\leq v$  for all $v\in V$;
\item \label{cond:p_in_nv} $P(v)\in\mathcal{N}(v)$ for all $v\in V$;
\item \label{cond:cpv_leq_cv} $CC[P(v)]\leq CC[v]$ for all $v\in V$; 
\item \label{cond:crv_eq_rv} $CC[v] =v \iff P(v)=v$ for all $v\in V$; and 
\item \label{cond:h_is_fr} Directed graph described by parent array $H=(V,E_{H})$, where $E_{H}=\left\{ (v,P(v)),\forall v\in V\right\} $
describes a forest. 
\end{conditionList}
\end{thm}

\textbf{\emph{Proof:}}  We will show that if all conditions of
\cref{thm:ss_valid} holds then the conditions of \cref{thm:valid_cc} also
hold. From \cref{cond:ccv_leq_v} of \cref{thm:ss_valid}, we already have
$CC[v]\leq v\ \forall v \in V$. To prove the second part,  we find a lower
bound on the value of $CC[v]$.

\begin{enumerate}

\item From \cref{cond:h_is_fr}, if $H$ is a forest, then each tree in $H$ 
will have a root node.  We denote the root of tree containing $v$ by $\mathcal
{R}(v)$  for any vertex $v$. Further, the sequence 
$\{ P(v),\  P^{2}(v), \ldots, \}  $  converges to $\mathcal{R}(v)$. So we can 
also write $\mathcal{R}(v)$ as:
\begin{equation}
\label{eq:ss_vpiv}
 \mathcal{R}(v) = P^{\infty}(v)
\end{equation}

\item The \cref{cond:p_in_nv} implies $v$ and $P(v)$ are in the same connected component in the graph $G$.  Similarily, $P(v)$ and $P^{2}(v)$ are in the same connected component in $G$.  Verily,  $\{ v,\  P(v),\  P^{2}(v), \ldots,  \mathcal{R}(v) \}  $
are in the same component in $G$.  So at the end of \sv~iteration they all will aquire the same final label. Thus we have:
\begin{equation}
\label{eq:ss_ivriv}
CC^\infty(v) = CC^{\infty}[{\mathcal{R}}(v)]
\end{equation} 

\item The \cref{cond:cpv_leq_cv} implies $ CC[v] \geq CC[P(v)] $  and it also 
implies $CC[P(v)]\geq CC[P^{2}(v)]$ .  Thus, 
$CC[v] \geq CC[P(v)]\geq CC[P^{2}(v)] \ldots CC[ \mathcal{R}(v)]$. Hence, 
%
\begin{equation}
\label{eq:ss_vrv}
CC[v] \geq CC[ \mathcal{R}(v)]
\end{equation} 



\item Since the root of the tree $\mathcal{R}(v)$ is the parent of itself: $ \mathcal{R}(v) = P(\mathcal{R}(v))$. The \cref{cond:crv_eq_rv} implies that the label of the root $CC[ \mathcal{R}(v)]$ is root itself:
\begin{equation}
CC[ \mathcal{R}(v)] = \mathcal{R}(v) 
\end{equation} 

\item Combining \cref{eq:ss_vpiv,eq:ss_vrv,eq:ss_ivriv}, we get 
\begin{align}
\label{eq:ss_vhs}
CC[v] & \geq   CC[ \mathcal{R}(v)] \geq CC^{\infty}[ \mathcal{R}(v)]  = CC^{\infty}[ (v)]  \\
CC[v] & \geq  CC^{\infty}[ (v)]
\end{align}

\item From \cref{cond:ccv_leq_v}, we already have $CC[v]\leq v$. Thus, if all conditions of \cref{thm:ss_valid} hold then
we must have 
\begin{equation}
\label{eq:ss_prf}
v \geq CC[v]  \geq  CC^{\infty}[ (v)] \quad \forall v \in V.
\end{equation}
\end{enumerate}

Verily,  from \cref{thm:valid_cc} we conclude that if all conditions of \cref{thm:ss_valid} hold for a state $S=\{CC, P\}$,
then $S$ is a valid state. 


% \item $CC[v]\leq v$  for all $v\in V$;
% \begin{equation}
% E=mc^2
% \end{equation}
% \item $P(v)\in\mathcal{N}(v)$ for all $v\in V$;
% \item $CC[P(v)]\leq CC[v]$ for all $v\in V$; 
% \item $CC[v] =v \iff P(v)=v$ for all $v\in V$; and 
% \item Directed graph described by parent array $H=(V,E_{H})$, where $E_{H}=\left\{ (v,P(v)),\forall v\in V\right\} $
% describes a forest. 


